# 前言
最近几年游戏引擎的发展可以说是十分迅速，各个商业引擎也做了很多不同反向的尝试。例如Unity的DOTS框架、可编程渲染管线UPR以及适用于高画质需求的HDRP。对于我们而言，我们会发现市面上的精品游戏的画面、性能会越来越好，这其实是硬件发展以及引擎发展的共同作用导致的。那对于游戏QA是否需要了解游戏引擎的原理以及发展前景，我是认为可以了解一部分，说不定在之后的工作当中可以用到。
# 游戏引擎基本介绍
游戏引擎的定义以及发展历史我就不做过多概述了，本篇文章主要就我们会接触到的游戏引擎的模块以及游戏引擎的架构做个简单介绍。
## 模块划分
对于我们可以接触到的游戏引擎模块而言，大致可以分成渲染、物理、逻辑、动画、AI等模块，接下来简单介绍一下。
### 渲染模块
渲染模块主要负责游戏画面的输出，主要是由GPU负责计算，而CPU是通过调用图形API通知GPU。一个完整的渲染流程实际是经典的生产者消费者模式，由CPU负责应用阶段（加载数据到显存、设置渲染状态、调用图形API），而GPU负责几何阶段以及光栅化阶段。
图形API有许多的版本，例如Vulkan、OpenGL、Metal，所以在渲染模块的底层是有一套比较复杂的shader适配，这其实也是兼容性需要关注的，例如在部分机型上OpenGL版本为2.0，在部分机型上为3.0。
那么在渲染模块，有什么可以讲的部分呢。
在现代渲染中，研究比较多的就是光照，但是无论是在实时渲染或者说是离线渲染中，光照是一个十分重要以及耗时的地方。
光照的作用是什么呢，在我们建立好一个立体模型后，并且赋予它一个合适的纹理贴图，以及设置一个shader。
如果仅仅只是这样设置，我们将看不到这个模型，是因为缺少了光源。游戏引擎做的事情就是模拟现实世界，缺少了光源，我们就相对于在黑暗的房间里去查看这个模型。在我们重新设置了一个光源后，如果没有在shader里设置相应的光照处理的代码话，我们也是无法看到这个模型的。
那么光照到底是怎么计算的呢，在现代物理学中，我们可以看到物体，主要是光在物体表面发生了反射，但是光在物体表面不仅仅只产生了反射，还有吸收以及折射。James Kajiya 在1986首次提出了BRDF渲染方程，这个方程解释了世界上所有物体的渲染逻辑。
$$
\begin{aligned}
dE(\mathbf{\omega_i})&=L(\mathbf{\omega_i})cos\theta_idw_i
\end{aligned}
$$
该方程介绍了一个点在收到另一个方向的光照后，通过不同的反向折射出去。
$$
f_r(\mathbf{\omega_i\rightarrow\omega_r})= \frac{dL_r(\mathbf{\omega_r})}{dE_i(\mathbf{\omega_i})}=\frac{dL_r(\mathbf{\omega_r})}{Li\mathbf(\omega_i)\theta_id\omega_i}[\frac{1}{sr}]
$$

$$
L_r(\mathbf{\Chi,\omega_r})= \int_{H^2}fr(\mathbf{\Chi,\omega_i\rightarrow\omega_r})L_i(\mathbf{\Chi,\omega_i})cos\theta_id\omega_i
$$

$$
L_o(\mathbf{\Chi,\omega_o})= L_e(\mathbf{\Chi,\omega_o})+\int_{H^2}L_i(\mathbf{\Chi,\omega_i})fr(\mathbf{\Chi,\omega_i,\omega_o})cos\theta_id\omega_i
$$
#### 
####

### 物理模块
### 逻辑模块
### 动画模块
### AI模块
## 架构
### 单线程模式
### 多线程模式
### JOB system？
### 面向数据？